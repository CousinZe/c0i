
(defun (string v)
    (cond
        [(str?) v]
        [else (literal v)]))


(defun (list-map fun lst)
    (cond
        [(pair? lst) (let (
            [h (fun (car lst))]
            [t (list-map (cdr lst))])
            (cons h t))]
        [else (fun lst)]))


(defun (list-fold fun init lst)
    (define h (car lst))
    (define d (cdr lst))
    (cond
        [(pair? d) (list-fold fun (fun init h) d)]
        [(null? d) (fun init h)]
        [else (error)]))


(defun (list-reduce fun lst)
    (cond
        [(pair? lst) (list-fold fun (car lst) (cdr lst))]
        [(null? lst) nil]
        [else (error lst)]))


(defun (fold fun init lst)
    (list-fold fun init lst))


(defun (reduce fun lst)
    (list-reduce fun lst))


;(defun (list? lst)
;    (cond
;        [(pair? lst) false]))


(defun (+ . args)
    (define fun
        (cond
            [(int? (car args)) +i]
            [(uint? (car args)) +u]
            [(float? (car args)) +f]))
    (fold fun 0 args))


(defun (- . args)
    (define fun
        (cond
            [(int? (car args)) -i]
            [(uint? (car args)) -u]
            [(float? (car args)) -f]))
    (reduce fun args))


(defun (* . args)
    (define fun
        (cond
            [(int? (car args)) *i]
            [(uint? (car args)) *u]
            [(float? (car args)) *f]))
    (fold fun 1 args))


(defun (/ . args)
    (define fun
        (cond
            [(int? (car args)) /i]
            [(uint? (car args)) /u]
            [(float? (car args)) /f]))
    (reduce fun args))

